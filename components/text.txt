<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NavigateIO-Inspired Animated Text On Scroll | Codegrid</title>
    <link rel="stylesheet" href="styles.css" />
</head>
<body>
    <section class="hero">
        <div class="copy-container">
            <h1>Playground for bold ideas and creative interfaces.</h1>
        </div>
    </section>
    <section class="about">
        <div class="copy-container"></div>
    </section>
    <section class="cta">
        <div class="copy-container">
            <h1>Join Huebase now to create expressive interfaces.</h1>
        </div>
    </section>
    <section class="features">
        <div class="copy-container"></div>
    </section>
    <section class="outro">
        <div class="copy-container"></div>
    </section>
    
    <section class="about anime-text-container">
        <div class="copy-container">
            <div class="anime-text">
                <p>
                    Huebase is a vibrant space for designers who think in motion and
                    build with intent. It's more than a tool â€“ it's where bold ideas
                    turn into living interfaces, powered by color, rhythm, and creative
                    control.
                </p>
                <p>
                    We believe great design starts with clarity and expression ends.
                    That's why Huebase is built to simplify your workflow while
                    amplifying your creativity each. From the first concept to the final
                    handoff, it's a space where your ideas take shape and move, your
                    palette comes to life, and your interface begins.
                </p>
            </div>
        </div>
    </section>
    
    <section class="cta">
        <div class="copy-container">
            <h1>Join Huebase now to create expressive interfaces.</h1>
        </div>
    </section>
    
    <section class="features anime-text-container">
        <div class="copy-container">
            <div class="anime-text">
                <p>
                    Huebase brings motion, structure, and creativity together in one
                    intuitive space. Design responsive layouts, choreograph smooth
                    animations, and explore rich storytelling visuals. All without
                    writing a single line of code or program.
                </p>
                <p>
                    With built-in support for interactive components, scroll-based
                    effects, and real-time previews, Huebase lets you prototype bold,
                    expressive interfaces that feel as good as they look. It's the
                    fastest way to bring your creative vision to life on the modern web.
                </p>
            </div>
        </div>
    </section>

    <script type="module" src="script.js"></script>
</body>
</html>











import gsap from "gsap";
import { ScrollTrigger } from "gsap/ScrollTrigger";
import Lenis from "lenis";

document.addEventListener("DOMContentLoaded", () => {
    gsap.registerPlugin(ScrollTrigger);

    const lenis = new Lenis();
    lenis.on("scroll", ScrollTrigger.update);
    gsap.ticker.add((time) => {
        lenis.raf(time * 1000);
    });
    gsap.ticker.lagSmoothing(0);

    const animeTextParagraphs = document.querySelectorAll(".anime-text p");

    const wordHighlightBgColor = "60, 60, 60";

    const keywords = [
        "vibrant",
        "living",
        "clarity",
        "expression",
        "shape",
        "intuitive",
        "storytelling",
        "interactive",
        "vision",
    ];

    animeTextParagraphs.forEach((paragraph) => {
        const text = paragraph.textContent;
        const words = text.split(/\s+/);
        paragraph.innerHTML = "";

        words.forEach((word) => {
            if (word.trim()) {
                const wordContainer = document.createElement("div");
                wordContainer.className = "word";

                const wordText = document.createElement("span");
                wordText.textContent = word;

                const normalizedWord = word.toLowerCase().replace(/[.,!?:*'"]/g, "");
                if (keywords.includes(normalizedWord)) {
                    wordContainer.classList.add("keyword-wrapper");
                    wordText.classList.add("keyword", normalizedWord);
                }

                wordContainer.appendChild(wordText);
                paragraph.appendChild(wordContainer);
            }
        });
    });

    const animeTextContainers = document.querySelectorAll(
        ".anime-text-container"
    );

    animeTextContainers.forEach((container) => {
        ScrollTrigger.create({
            trigger: container,
            pin: container,
            start: "top top",
            end: `+=${window.innerHeight * 4}`,
            pinSpacing: true,
        });
    });

    animeTextContainers.forEach((container) => {
        const words = Array.from(
            container.querySelectorAll(".anime-text .word")
        );
        const totalWords = words.length;

        words.forEach((word, index) => {
            const wordText = word.querySelector("span");

            if (progress <= 0.7) {
                const progressTarget = 0.7;
                const revealProgress = Math.min(1, progress / progressTarget);

                const overlapWords = 15;
                const totalAnimationLength = 1 + overlapWords / totalWords;

                const wordStart = index / totalWords;
                const wordEnd = wordStart + overlapWords / totalWords;

                const timelineScale =
                    1 /
                    Math.min(
                        totalAnimationLength,
                        1 + (totalWords - 1) / totalWords + overlapWords / totalWords
                    );

                const adjustedStart = wordStart * timelineScale;
                const adjustedEnd = wordEnd * timelineScale;
                const duration = adjustedEnd - adjustedStart;

                const wordProgress =
                    revealProgress <= adjustedStart
                        ? 0
                        : revealProgress >= adjustedEnd
                        ? 1
                        : (revealProgress - adjustedStart) / duration;

                word.computedStyleMap.opacity = wordProgress;

                const backgroundFadeStart =
                    wordProgress >= 0.9 ? (wordProgress - 0.9) / 0.1 : 0;
                const backgroundOpacity = Math.max(0, 1 - backgroundFadeStart);
                word.style.backgroundColor = `rgba(${wordHighlightBgColor}, ${backgroundOpacity})`;

                const textRevealThreshold = 0.9;
                const textRevealProgress =
                    wordProgress >= textRevealThreshold
                        ? (wordProgress - textRevealThreshold) /
                          (1 - textRevealThreshold)
                        : 0;

                wordText.style.opacity = Math.pow(textRevealProgress, 0.5);
            } else {
                const reverseProgress = (progress - 0.7) / 0.3;
                word.style.opacity = 1;
                const targetTextOpacity = 1;

                const reverseOverlapWords = 5;
                const reverseWordStart = index / totalWords;
                const reverseWordEnd =
                    reverseWordStart + reverseOverlapWords / totalWords;

                const reverseTimelineScale =
                    1 / Math.max(1, (totalWords - 1) / totalWords + reverseOverlapWords / totalWords);

                const reverseAdjustedStart =
                    reverseWordStart * reverseTimelineScale;
                const reverseAdjustedEnd = reverseWordEnd * reverseTimelineScale;
                const reverseDuration = reverseAdjustedEnd - reverseAdjustedStart;

                const reverseWordProgress =
                    reverseProgress <= reverseAdjustedStart
                        ? 0
                        : reverseProgress >= reverseAdjustedEnd
                        ? 1
                        : (reverseProgress - reverseAdjustedStart) / reverseDuration;

                if (reverseWordProgress > 0) {
                    wordText.style.opacity =
                        targetTextOpacity * (1 - reverseWordProgress);
                    word.style.backgroundColor = `rgba(${wordHighlightBgColor}, ${reverseWordProgress})`;
                } else {
                    wordText.style.opacity = targetTextOpacity;
                    word.style.backgroundColor = `rgba(${wordHighlightBgColor}, 0)`;
                }
            }
        });
    });
});
